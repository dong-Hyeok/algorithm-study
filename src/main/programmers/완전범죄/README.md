# 문제: 완전범죄 (Lv 2)

📌 [문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/389480?language=java)

---

## ▪️ 조건 정리

- `1 ≤ info.length ≤ 40`
- `1 ≤ 흔적 개수(info[i][0], info[i][1]) ≤ 3`
- `1 ≤ n ≤ 120` (A 도둑의 최대 허용 흔적)
- `1 ≤ m ≤ 120` (B 도둑의 최대 허용 흔적)

---

## ▪️ 목표

모든 물건을 도둑 A 또는 B가 나눠서 훔친다.
- 단, A 도둑의 누적 흔적 수가 `n` 이상이거나
- B 도둑의 누적 흔적 수가 `m` 이상이면 **탐색 중단**
- 가능한 경로 중에서 **A 도둑의 흔적 누적 총합이 최소가 되도록** 해야 함
- 만약 **어떤 조합으로도 두 도둑 모두 잡히지 않게 훔칠 수 없다면 -1 반환**

---

## ▪️ 접근 방법: DFS + Pruning + Memoization

- DFS 완전탐색으로 모든 경우의 수 확인
- 누적 흔적이 한도(`n`, `m`)를 초과하면 **바로 탐색 종료 (pruning)**
- `dp[i][a][b]` 형태로 **메모이제이션** 하여 중복 탐색 방지
- 최종 반환값은 **A 도둑이 남긴 누적 흔적의 최소값**

### 탐색 공간의 최악 크기
```
최대 info.length(40) × n(120) × m(120) = 576,000
```

---

## ▪️ 예시

```
info = [[1, 2], [2, 3], [2, 1]]
n = 4
m = 4
expected result = 2
```

### DP[0] (i = 0)
```
[[2, '.', '.', '.'],
 ['.', '.', '.', '.'],
 ['.', '.', '.', '.'],
 ['.', '.', '.', '.']]
```

### DP[1] (i = 1)
```
[['.', '.', 2, '.'],
 [3, '.', '.', '.'],
 ['.', '.', '.', '.'],
 ['.', '.', '.', '.']]
```

### DP[2] (i = 2)
```
[['.', '.', '.', '.'],
 ['.', '.', '.', 3],  ← 예: dp[2][1][3] = 3
 ['.', '.', 2, '.'],
 [3, '.', '.', '.']]
```

### DP[3] (i = 3, 탐색 종료지점)
```
[['.', '.', '.', '.'],
 ['.', '.', '.', '.'],
 ['.', '.', '.', '.'],
 ['.', '.', '.', '.']]
```

---
